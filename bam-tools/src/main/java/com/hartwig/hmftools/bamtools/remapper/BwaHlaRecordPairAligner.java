package com.hartwig.hmftools.bamtools.remapper;

import static com.hartwig.hmftools.common.bam.SupplementaryReadData.ALIGNMENTS_DELIM;

import java.util.ArrayList;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import com.hartwig.hmftools.common.bam.SamRecordUtils;
import com.hartwig.hmftools.common.bam.SupplementaryReadData;
import com.hartwig.hmftools.common.genome.refgenome.RefGenomeVersion;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.umccr.java.hellbender.utils.bwa.BwaMemAlignment;

import htsjdk.samtools.SAMFileHeader;
import htsjdk.samtools.SAMRecord;

public class BwaHlaRecordPairAligner implements HlaRecordPairAligner
{

    private final PairAligner mAligner;
    private final SAMFileHeader mHeader;
    private final RefGenomeVersion mRefGenomeVersion;

    public BwaHlaRecordPairAligner(final PairAligner aligner,
            final SAMFileHeader newHeader,
            final RefGenomeVersion refGenomeVersion)
    {
        mAligner = aligner;
        mHeader = newHeader;
        mRefGenomeVersion = refGenomeVersion;
    }

    @Override
    public List<SAMRecord> alignPair(final RecordPair pair)
    {
        ImmutablePair<List<BwaMemAlignment>, List<BwaMemAlignment>> alignments =
                mAligner.alignSequences(pair.leftBasesForRealignment(), pair.rightBasesForRealignment());
        AlignmentsList leftAlignments = new AlignmentsList(alignments.getLeft());
        AlignmentsList rightAlignments = new AlignmentsList(alignments.getRight());

        // Get the most suitable alignment pair from among the possibilities
        // generated by these lists of alignments.
        AlignmentsSelector alignmentsSelector = new AlignmentsSelector(leftAlignments, rightAlignments);
        HlaAlignmentPair bestAlignedPair = alignmentsSelector.bestAlignmentPair(mRefGenomeVersion);
        SAMRecord principalLeftRemapped = bestAlignedPair.Left.createSamRecord(mHeader, pair.leftData(), bestAlignedPair.Right);
        SAMRecord principalRightRemapped = bestAlignedPair.Right.createSamRecord(mHeader, pair.rightData(), bestAlignedPair.Left);

        // Because our alignments have been calculated by BWA one pair at a time,
        // they are missing the "proper pair" flag, which is set based on statistical
        // properties of large batches. Put this back if the pair are close together.
        fixProperPairFlag(principalLeftRemapped);
        fixProperPairFlag(principalRightRemapped);

        List<SAMRecord> lefts = new ArrayList<>();
        List<SAMRecord> rights = new ArrayList<>();
        lefts.add(principalLeftRemapped);
        rights.add(principalRightRemapped);

        // Calculate and add any supplementary alignments.
        leftAlignments.supplementaryAlignments()
                .forEach(left -> lefts.add(left.createSamRecord(mHeader, pair.leftData(), bestAlignedPair.Right)));
        rightAlignments.supplementaryAlignments()
                .forEach(right -> rights.add(right.createSamRecord(mHeader, pair.rightData(), bestAlignedPair.Left)));

        // Add SA tags for supplementaries.
        addSupplementaryReadTags(lefts);
        addSupplementaryReadTags(rights);

        List<SAMRecord> result = new ArrayList<>();
        result.addAll(lefts);
        result.addAll(rights);
        return result;
    }

    static void addSupplementaryReadTags(List<SAMRecord> records)
    {
        if (records.size() < 2) {
            return;
        }
        // Setting the SA tag of the records changes their hash values, so we use an IdentityHashMap.
        Map<SAMRecord, String> recordToTag = new IdentityHashMap<>();
        records.forEach(record -> recordToTag.put(record, createSATag(record)));
        records.forEach(record -> {
            List<String> tagsForRecord = new ArrayList<>();
            records.forEach(otherRecord -> {
                if (record != otherRecord) {
                    tagsForRecord.add(recordToTag.get(otherRecord));
                }
            });
            String tags = String.join("", tagsForRecord);
            record.setAttribute(SamRecordUtils.SUPPLEMENTARY_ATTRIBUTE, tags);
        });
    }

    static String createSATag(SAMRecord record)
    {
        return SupplementaryReadData.createSupplementaryReadDataForRecord(record).asSamTag() + ALIGNMENTS_DELIM;
    }

    private static void fixProperPairFlag(SAMRecord record)
    {
        int insertLength = Math.abs(record.getInferredInsertSize());
        final boolean insertLengthOK = insertLength < RemapperConstants.MAX_LENGTH_FOR_PROPER_PAIR && insertLength > RemapperConstants.MIN_LENGTH_FOR_PROPER_PAIR;
        final boolean sameStrand = Objects.equals(record.getReferenceIndex(), record.getMateReferenceIndex());
        if(insertLengthOK && sameStrand)
        {
            record.setProperPairFlag(true);
        }
    }
}
